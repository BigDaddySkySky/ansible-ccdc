#!/usr/bin/env python3
"""
CCDC Log Watcher Service
Monitors auth logs for suspicious activity and triggers alerts.
Generated by Ansible - DO NOT EDIT MANUALLY
"""

import re
import subprocess
import sys
import time
from collections import defaultdict
from datetime import datetime, timedelta
from pathlib import Path

# Configuration (injected by Ansible)
WEBHOOK_URL = "{{ discord_webhook_url }}"
HOSTNAME = "{{ inventory_hostname }}"
ALERT_SCRIPT = "/usr/local/bin/ccdc_alert.py"
FAILED_LOGIN_THRESHOLD = {{ intrusion_detection_failed_login_threshold }}
FAILED_LOGIN_WINDOW = {{ intrusion_detection_failed_login_window }}
CHECK_INTERVAL = {{ intrusion_detection_log_watch_interval }}

# Log files to monitor
LOG_FILES = [
{% for log in intrusion_detection_monitored_logs[ansible_os_family | lower] %}
    "{{ log }}",
{% endfor %}
]

# Suspicious patterns
SUSPICIOUS_PATTERNS = [
{% for pattern in intrusion_detection_suspicious_patterns %}
    re.compile(r"{{ pattern }}"),
{% endfor %}
]

# State tracking
failed_logins = defaultdict(list)  # IP -> [timestamp, ...]
last_positions = {}  # log_file -> byte_position


def get_file_position(log_file: Path) -> int:
    """Get last read position or start from end if new."""
    if log_file in last_positions:
        return last_positions[log_file]
    
    # Start from end of file for new monitors
    try:
        return log_file.stat().st_size
    except FileNotFoundError:
        return 0


def read_new_lines(log_file: Path):
    """Read only new lines since last check."""
    try:
        current_size = log_file.stat().st_size
    except FileNotFoundError:
        return []
    
    last_pos = get_file_position(log_file)
    
    # Handle log rotation (file got smaller)
    if current_size < last_pos:
        last_pos = 0
    
    if current_size == last_pos:
        return []  # No new data
    
    with open(log_file, 'r', errors='ignore') as f:
        f.seek(last_pos)
        new_lines = f.readlines()
        last_positions[log_file] = f.tell()
    
    return new_lines


def check_failed_logins(line: str):
    """Detect failed login attempts and alert on threshold."""
    # Pattern: Failed password for USER from IP
    match = re.search(r'Failed password for (\S+) from ([\d.]+)', line)
    if not match:
        return
    
    user, ip = match.groups()
    now = datetime.now()
    
    # Add to tracking
    failed_logins[ip].append(now)
    
    # Clean old attempts outside window
    cutoff = now - timedelta(seconds=FAILED_LOGIN_WINDOW)
    failed_logins[ip] = [t for t in failed_logins[ip] if t > cutoff]
    
    # Check threshold
    if len(failed_logins[ip]) >= FAILED_LOGIN_THRESHOLD:
        alert_message = f"Failed login threshold exceeded: {len(failed_logins[ip])} attempts from {ip} for user {user}"
        send_alert("warning", alert_message, details=line)
        
        # Reset counter to avoid spam
        failed_logins[ip] = []


def check_suspicious_commands(line: str):
    """Detect suspicious command patterns."""
    for pattern in SUSPICIOUS_PATTERNS:
        if pattern.search(line):
            alert_message = f"Suspicious command detected: pattern '{pattern.pattern}'"
            send_alert("critical", alert_message, details=line)
            break  # Only alert once per line


def send_alert(severity: str, message: str, details: str = None):
    """Send alert via discord_alert.py script."""
    cmd = [
        sys.executable,
        ALERT_SCRIPT,
        "--webhook", WEBHOOK_URL,
        "--severity", severity,
        "--message", message,
        "--host", HOSTNAME
    ]
    
    if details:
        cmd.extend(["--details", details])
    
    try:
        subprocess.run(cmd, timeout=15, check=False)
    except Exception as e:
        print(f"Failed to send alert: {e}", file=sys.stderr)


def monitor_loop():
    """Main monitoring loop."""
    print(f"CCDC Log Watcher started on {HOSTNAME}")
    print(f"Monitoring: {', '.join(LOG_FILES)}")
    
    while True:
        try:
            for log_file_path in LOG_FILES:
                log_file = Path(log_file_path)
                
                if not log_file.exists():
                    continue
                
                new_lines = read_new_lines(log_file)
                
                for line in new_lines:
                    check_failed_logins(line)
                    check_suspicious_commands(line)
            
            time.sleep(CHECK_INTERVAL)
            
        except KeyboardInterrupt:
            print("\nShutting down log watcher...")
            break
        except Exception as e:
            print(f"Error in monitoring loop: {e}", file=sys.stderr)
            time.sleep(CHECK_INTERVAL)


if __name__ == "__main__":
    monitor_loop()